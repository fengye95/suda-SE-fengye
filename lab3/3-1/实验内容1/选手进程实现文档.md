你说得对！我过度设计了。选手进程应该很简单：

# player 选手进程

<br>

## 功能概述
选手进程是游戏的简单参与者，负责：
1. **连接消息队列** - 连接到裁判创建的消息队列
2. **告知连接** - 向裁判发送连接确认
3. **响应请求** - 接收裁判的出拳指令并回复随机选择
4. **被动退出** - 由裁判进程控制生命周期

<br>

## 🎯 实际代码流程：
```
→ 连接消息队列 
→ 发送连接确认
→ 等待裁判指令 → 接收消息 → 回复随机出拳
→ (裁判结束游戏时自动退出)
```

<br>

## 核心代码实现

#### 1. 连接消息队列
```c
int get_message_queue() {
    key_t key = ftok("/tmp", 'R');
    int msgid = msgget(key, 0666);
    if (msgid == -1) {
        perror("msgget failed - 请先启动裁判进程");
        exit(1);
    }
    return msgid;
}
```

<br>

#### 2. 发送连接确认
```c
// 发送连接确认消息
void send_connection_message(int msgid, int player_id)
{
    struct msg_packet message;
    message.msg_type = MSG_TYPE_CONNECT_ACK;
    message.player_id = player_id;
    message.choice = 0;
    message.round = 0;
    printf("玩家%d 发送连接请求\n", player_id);
    if (msgsnd(msgid, &message, sizeof(message) - sizeof(long), 0) == -1)
    {
        perror("发送连接消息失败");
        exit(1);
    }
    else
    {
        printf("玩家%d: 已连接\n", player_id);
    }
}
```

<br>

#### 3. 处理裁判消息（简化版）
```c
void handle_referee_message(int msgid, int player_id) {
    struct msg_packet message;
    
    while (1) {
        // 阻塞等待裁判指令
        msgrcv(msgid, &message, sizeof(message) - sizeof(long), player_id, 0);
        
        // 随机出拳
        message.choice = rand() % 3;
        message.msg_type = player_id | 4;  // 回复消息类型
        
        // 回复裁判
        msgsnd(msgid, &message, sizeof(message) - sizeof(long), 0);
        
        printf("玩家%d: 第%d回合出拳 %s\n", 
               player_id, message.round,
               message.choice == 0 ? "石头" :
               message.choice == 1 ? "剪刀" : "布");
    }
}
```

<br>

#### 4. 主程序
```c
int main() {
    srand(time(NULL) + getpid());
    
    printf("玩家进程启动\n");
    int msgid = get_message_queue();
    int player_id = (getpid() % 2) + 1;
    
    send_connection_message(msgid, player_id);
    handle_referee_message(msgid, player_id);
    
    return 0;
}
```

<br>

## 设计特点

1. **极简设计** - 只做最基本的消息收发
2. **被动响应** - 完全由裁判驱动
3. **无状态** - 不记录游戏状态，只响应当前回合
4. **自动退出** - 当裁判结束游戏时自然退出

**选手进程就是个"应答机"**，所有游戏逻辑都在裁判进程中。


#### 5. 新添: 玩家从裁判获取玩家ID
```c
#define MSG_TYPE_ID_ASSIGN 100   // 裁判→玩家：分配ID
#define MSG_TYPE_CONNECT_ACK 101 // 玩家→裁判：连接确认

int get_assigned_id(int msgid)
{
    struct msg_packet message;
    msgrcv(msgid, &message, sizeof(message) - sizeof(long), MSG_TYPE_ID_ASSIGN, 0);
    return message.player_id;
}

```
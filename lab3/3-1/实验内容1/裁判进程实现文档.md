
# referee 裁判进程

<br>


## 功能概述
裁判进程是整个游戏的控制中心，负责：
1. **创建和管理消息队列**
   - 初始化IPC通信设施
   - 清理消息队列资源

2. **协调游戏回合**
   - 按顺序通知玩家出拳
   - 等待玩家回复（带超时机制）
   - 根据游戏规则判断胜负

3. **游戏状态管理**
   - 记录每回合出拳选择
   - 统计胜负和平局次数
   - 监控玩家超时情况

4. **输出游戏结果**
   - 实时显示每回合战况
   - 输出最终胜负统计


<br>

## 🎯 实际代码流程：
```
→ 创建消息队列 
→ 循环N回合 
    → 每回合：玩家1出拳 → 玩家2出拳 → 判断胜负 → 统计 
→ 最终报告
```

<br>

## 详细设计
#### 1. 创建消息队列
- 使用 `ftok(".", 'R')` 基于当前目录生成唯一key
- 通过 `msgget()` 系统调用创建消息队列
- **强制创建策略**：如果key对应的消息队列已存在，先删除再创建
- **安全性**：个人虚拟机环境，无需担心key冲突影响其他系统资源
- **权限设置**：0666（所有用户可读写），简化权限管理

<br>

#### 2. 协调游戏回合
- 设计思路：
    - 1. 回合制流程：玩家1 → 玩家2 → 判断胜负
    - 2. 超时机制：一定时间内未回复视为弃权
    - 3. 消息时序：
        - 裁判 --type=1--> 玩家1 --type=5--> 裁判
        - 裁判 --type=2--> 玩家2 --type=6--> 裁判
    - 4. 状态管理：
        - 记录每个玩家的出拳选择 (石头(0) 剪刀(1) 布(2))
        - 处理超时情况（choice = -1）
    - 5. 胜负判定：
        - 超时判负
        - 正常出拳(无超时)按 (choice1 + 1) % 3 == choice2 规则
        - 更新比分统计: 0:平局, 1:玩家1 胜, 2:玩家2 胜
    - 6. 实时回合结果：每回合结束后立即显示双方出拳和胜负结果

<br>


## 核心代码实现

#### 0. 数据结构定义
```c
// 消息结构 - IPC通信载体
struct msg_packet {
    long msg_type;  // 消息类型：玩家ID(1/2)或玩家ID|4(5/6)
    int choice;     // 出拳选择：0=石头,1=剪刀,2=布,-1=超时
    int round;      // 回合数
    int player_id;  // 发送者ID：1=玩家1, 2=玩家2
    int timeout_seconds; // 超时时间(秒)：裁判告知选手的响应时限
};

// 游戏状态 - 全局状态维护
struct game_state {
    int msgid;      // 消息队列标识符
    int rounds;     // 总回合数
    int scores[3];  // 胜负统计：0=平局,1=玩家1胜,2=玩家2胜
    int timeouts[3];// 超时统计：[0]未用,[1]=玩家1超时,[2]=玩家2超时
};

// 出拳名称 - 用户友好显示
const char* choice_name(int choice) {
    switch(choice) {
        case 0: return "石头";  // 石头胜剪刀
        case 1: return "剪刀";  // 剪刀胜布  
        case 2: return "布";    // 布胜石头
        case -1: return "超时"; // 超时判负
        default: return "未知"; // 异常处理
    }
}
```

<br>

#### 1.创建和管理消息队列
```c
// 创建和管理消息队列
int create_message_queue() {
    // ftok(path, id): file to key: 路径和ID生成唯一的IPC key
    // 在裁判和玩家进程中使用相同的（path, id）， 以获取相同的key访问同一个消息队列
    key_t key = ftok("/tmp", 'R');

    // 删除可能存在的旧队列（不检查是否存在）
    int old_msgid;
    if ((old_msgid = msgget(key, 0666)) != -1) {
        msgctl(old_msgid, IPC_RMID, NULL);
    }
    
    // 创建新队列
    int msgid = msgget(key, 0666 | IPC_CREAT | IPC_EXCL);
    if (msgid == -1) {
        perror("msgget failed");
        exit(1);
    }
    
    return msgid;
}
```

<br>

#### 2. 发送消息给玩家
```c
// 发送消息给玩家
void 
send_to_player(int msgid, int player_id, int round) {
    struct msg_packet message;
    message.msg_type = player_id;  // 类型为玩家ID
    message.round = round;        // 回合数
    message.player_id = player_id;
    message.timeout_seconds = TIMEOUT; // 超时时间(秒)：裁判告知响应时限
    
    if (msgsnd(msgid, &message, sizeof(message) - sizeof(long), 0) == -1) {
        printf("发送给玩家%d的消息失败: ", player_id);
        perror("msgsnd failed");
        exit(1);  // 直接退出程序
    }
}
```

<br>


#### 3. 接收玩家消息（带超时）
```c
// 接收玩家消息（带超时）
int receive_from_player(int msgid, int player_id, int *choice) {
    struct msg_packet message;
    time_t start_time = time(NULL);
    
    while (time(NULL) - start_time < TIMEOUT) {
        // 非阻塞接收
        if (msgrcv(msgid, &message, sizeof(message) - sizeof(long), player_id | 4, IPC_NOWAIT) != -1) {
            *choice = message.choice;
            return 1;  // 成功接收
        }
        
        if (errno != ENOMSG) {
            printf("接受玩家%d的消息失败: ", player_id);
            perror("msgrcv failed");
            exit(1);  // 直接退出程序
        }
        
        usleep(100 * 1000);  // 休眠100ms再检查
    }
    
    *choice = -1;  // 超时
    return 0;
}
```


#### 4. 判断胜负
```c
// 判断胜负
int judge_winner(int choice1, int choice2) {
    if (choice1 == choice2) return 0;  // 平局

    if (choice1 == -1) return 2;  // 玩家1超时，玩家2胜
    if (choice2 == -1) return 1;  // 玩家2超时，玩家1胜
    
    // 石头(0)胜剪刀(1), 剪刀(1)胜布(2), 布(2)胜石头(0)
    if ((choice1 + 1) % 3 == choice2) return 1;  // 玩家1胜
    return 2;  // 玩家2胜
}
```

<br>

#### 5. 运行游戏回合
```c
// 运行游戏回合
void run_game_round(struct game_state *game, int round) {
    printf("\n=== 第 %d 回合 ===\n", round);
    
    int choice1, choice2;
    
    // 通知玩家1出拳
    printf("裁判: 通知玩家1出拳...\n");
    send_to_player(game->msgid, 1, round);
    
    // 等待玩家1回复
    if (receive_from_player(game->msgid, 1, &choice1) <= 0) {
        printf("玩家1超时！\n");
        game->timeouts[1]++;
    }
    
    // 通知玩家2出拳
    printf("裁判: 通知玩家2出拳...\n");
    send_to_player(game->msgid, 2, round);
    
    // 等待玩家2回复
    if (receive_from_player(game->msgid, 2, &choice2) <= 0) {
        printf("玩家2超时！\n");
        game->timeouts[2]++;
    }
    
    // 显示出拳结果
    printf("玩家1出拳: %s\n", choice_name(choice1));
    printf("玩家2出拳: %s\n", choice_name(choice2));
    
    // 判断胜负
    int winner = judge_winner(choice1, choice2);
    game->scores[winner]++;
    
    switch(winner) {
        case 0: printf("结果: 平局\n"); break;
        case 1: printf("结果: 玩家1获胜\n"); break;
        case 2: printf("结果: 玩家2获胜\n"); break;
    }
    printf("\n");
}
```

<br>

#### 6. 显示最终结果
```c
// 显示最终结果
void show_final_results(struct game_state *game) {
    printf("\n=== 游戏结束 ===\n");
    printf("总回合数: %d\n", game->rounds);
    printf("平局: %d\n", game->scores[0]);
    printf("玩家1胜利: %d (超时: %d)\n", game->scores[1], game->timeouts[1]);
    printf("玩家2胜利: %d (超时: %d)\n", game->scores[2], game->timeouts[2]);
    
    if (game->scores[1] > game->scores[2]) {
        printf("最终胜者: 玩家1\n");
    } else if (game->scores[2] > game->scores[1]) {
        printf("最终胜者: 玩家2\n");
    } else {
        printf("最终结果: 平局\n");
    }
}
```

#### 7. 主程序逻辑 main()
```c

#define MAX_ROUNDS 100
#define TIMEOUT 5  // 5秒超时

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("用法: %s <回合数>\n", argv[0]);
        return 1;
    }
    
    int rounds = atoi(argv[1]);
    if (rounds <= 0 || rounds > MAX_ROUNDS) {
        printf("回合数必须在1-%d之间\n", MAX_ROUNDS);
        return 1;
    }
    
    printf("创建石头剪刀布游戏 (%d回合)...\n", rounds);
    
    // 初始化游戏状态
    struct game_state game;
    memset(&game, 0, sizeof(game));
    game.rounds = rounds;
    game.msgid = create_message_queue();
    
    printf("消息队列创建成功 (ID: %d)\n", game.msgid);
    printf("请在其他终端启动玩家进程: ./player\n");
    printf("等待玩家连接...\n");
    
    sleep(2);  // 给玩家时间连接
    
    // 运行所有回合
    for (int i = 1; i <= rounds; i++) {
        run_game_round(&game, i);
        sleep(1);  // 回合间隔
    }
    
    // 显示最终结果
    show_final_results(&game);
    
    // 清理消息队列
    msgctl(game.msgid, IPC_RMID, NULL);
    printf("消息队列已清理\n");
    
    return 0;
}
```

#### 8. 新加： 等待玩家连接
```c
#define MSG_TYPE_PUBLIC 0      // 公共消息类型，用于ID分配
#define MSG_TYPE_CONNECT 100   // 玩家连接确认消息类型

// 等待玩家连接确认
void wait_for_players_connection(int msgid)
{
    
    // 先分配两个玩家ID（简单发送到消息队列）
    struct msg_packet id_message;
    id_message.msg_type = MSG_TYPE_ID_ASSIGN; // 裁判→玩家：分配ID
    id_message.player_id = 1;                 // 玩家1 ID
    msgsnd(msgid, &id_message, sizeof(id_message) - sizeof(long), 0);
    
    id_message.player_id = 2; // 玩家2 ID
    msgsnd(msgid, &id_message, sizeof(id_message) - sizeof(long), 0);
    
    printf("等待玩家连接...\n");

    // 下面是原有的等待连接逻辑
    int connected_players = 0;
    struct msg_packet message;
    time_t start_time = time(NULL);

    while (connected_players < 2 && (time(NULL) - start_time < 30))
    {
        // 非阻塞接收连接确认消息
        // 玩家→裁判：连接确认
        if (msgrcv(msgid, &message, sizeof(message) - sizeof(long), MSG_TYPE_CONNECT_ACK, IPC_NOWAIT) != -1)
        {
            connected_players++;
            printf("玩家%d 连接成功!\n", message.player_id);
        }
        else if (errno != ENOMSG)
        {
            perror("接收连接消息失败");
            break;
        }

        // 显示等待状态
        if (connected_players == 0)
        {
            printf("等待玩家连接中... 已等待 %ld 秒\r", time(NULL) - start_time);
            fflush(stdout);
        }

        sleep(1);
    }

    printf("\n");
    if (connected_players == 2)
    {
        printf("✅ 所有玩家连接成功！开始游戏...\n");
    }
    else if (connected_players == 1)
    {
        printf("⚠️  只有1名玩家连接，继续等待或开始游戏...\n");
    }
    else
    {
        printf("❌ 没有玩家连接，请检查玩家进程是否启动\n");
        exit(1);
    }
}
```
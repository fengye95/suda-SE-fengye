



## 功能概述
- 动态分区分配方式的模拟
    - 输入要申请的内存大小
    - 输出分配情况： 
        - 成功则输出首地址， 失败则输出失败
        - 输出空闲分区表
        - 输出已分配分区表

- 页面置换算法的模拟
    - 统计FIFO, LRU, OPT的命中率

## 概要设计

#### 数据结构设计
- 空闲分区表和已分配分区表采用链表设计
- 链表节点： 首地址， 分配内存大小， 时间戳， 信号量（自旋锁）

<br>

#### 代码流程
- 1. 初始化空闲分区表640KB, 已分配分区表 NULL
- 2. 申请地址： 遍历空闲分区表， 寻找合适大小
- 3. 分配地址空间： 解除映射空闲分区表， 映射已分配分区表
- 4. 输出空闲分区表
- 5. 输出已分配分区表

<br>

#### 页面置换算法模拟
- 在代码流程2, 若找不到合适大小， 根据所选择的置换算法进行页面置换
- 在代码流程3, 统计置换算法所需要的信息

#### 详细设计
- 数据结构设计
```c
#include <semaphore.h>

struct run {
    struct run *next;
    struct run *prev;
    uint64 addr;
    uint64 size;
    uint64 timestamp;  // 和全局时间戳变量协作， 全局时间戳每次操作后-1
};

// 空闲分区表
struct mem_free {
    sem_t lock;   // 互斥信号量
    struct run *freelist;
} mem_free;

// 已分配分区表
struct mem_used {
    sem_t lock;   // 互斥信号量
    struct run *usedlist;
} mem_used;

uint64 timestamp = -1; // 64位最大值：-1的二进制解释成unsigned无符号时

```


<br>


- 初始化空闲分区表640KB, 已分配分区表 NULL
```c
#define PHYSTOP (640L << 12)
void
kfree() {
    struct run* r = malloc(sizeof(struct run));
    r->next = NULL;
    r->addr = 0;
    r->size = PHYSTOP;
    r->timestamp = -1;                 // mem_free的全局时间戳没有意义

    sem_init(&mem_free->lock, 0, 1);   // 初始互斥锁为1
    sem_init(&mem_used->lock, 0, 1);   // 初始互斥锁为1

    mem_free->freelist = r;
    mem_used->usedlist = NULL;
}
```


<br>


- 申请地址：申请成功返回首地址
```c
// 示例：首次适应算法 且 无页面置换算法
uint64
malloc (uint64 size) {
    struct run *start, *new;
    
    P(mem_free->lock);

    start = mem_free->freelist;

    while (start != NULL) {
        if (start->size >= size)
            break;
        else
            start = start->next;
    }

    if (start == NULL)
        return 0;   // 此处可添加页面置换算法

    // 裁减获取到的空间
    if (start->size > size) {
        new = justify(start, size);
    }

    add(mem_used, start);

    return size;
}

/*
将多余部分裁减掉

*/
struct run *
justify(struct run *old, uint64 size) {
    if (old->size <= size)
        return 0;
    
    struct run *new = malloc(sizeof(struct run));
    if (new == 0)
        return 0;

    new->next = old->next;
    new->prev = old->prev;
    old->next->prev = new;
    old->prev->next = new;

    new->size = old->size - size;
    new->addr = old->addr + old->size;
    new->timestamp = -1;        // mem_free 中分区的时间戳无意义

    old->prev = old->next = NULL;
    old->size = size;
    old->timestamp = timestamp;

    return new;
}

```
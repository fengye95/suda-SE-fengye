#### **1. 项目概述**

*   **1.1 项目名称**
    **操作系统内存管理模拟器**

*   **1.2 项目目标**
    1.  **动态分区存储管理**：模拟可变大小内存分区的分配与回收过程

*   **1.3 核心功能**
    1.  **内存分配与回收**：模拟进程申请和释放内存的过程
    2.  **分配算法模拟**：实现首次适应(FF)、最佳适应(BF)、最坏适应(WF)等分区分配算法
    3.  **分区状态管理**：维护并展示每个分区的关键属性（起始地址、大小、状态）

**【本部分目标】**：明确了项目的**最终形态**

---

#### **2. 总体设计**

*   **2.1 系统架构**
    *   **核心流程**：
        1.  **初始化阶段**：程序启动 → 初始化内存空间 → 从 `data/4-1.txt` 加载内存请求序列
        2.  **算法选择阶段**：显示算法菜单（FF/BF/WF）→ 接收用户选择的分配算法
        3.  **请求处理阶段**：按顺序处理每个内存请求 → 调用相应算法进行分配/回收 → 更新内存状态
        4.  **状态显示阶段**：实时显示空闲分区表和已分配分区表的变化
        5.  **统计输出阶段**：处理完成后输出内存利用率等统计信息

    *   **内存组织方式**：使用双向链表管理内存分区，支持分区的拆分与合并

*   **2.2 模块划分**
    1.  **数据管理模块**：负责读取 `data/4-1.txt` 文件，解析内存请求序列（包括分配请求和释放请求）
    2.  **算法执行模块**：实现三种核心分配算法（FF/BF/WF），处理内存的分配与回收操作
    3.  **内存管理模块**：维护内存状态，处理分区的创建、拆分、合并和状态更新
    4.  **显示输出模块**：实时格式化显示空闲分区表和已分配分区表，展示分区详细信息
    5.  **用户界面模块**：提供命令行交互界面，显示菜单、接收用户输入、控制处理流程

**【本部分目标】**：明确了程序的**核心流程**和**代码组织结构**，为详细设计提供框架基础

---

#### **3. 详细设计**

*   **3.1 数据存储设计**
    *   **内存请求序列**：`data/4-1.txt`
        - 格式：`[进程id] [操作类型] [参数]`
        - `1 a 100` - 进程1 请求分配 100KB内存
        - `2 r `    - 进程2 释放    全部内存
        - 第一行为初始内存大小， 单位KB
        - 第二行为请求总数量

    *   **内存分区结构**：
    ```c
    // 内存块状态枚举
    typedef enum {
        FREE = 0,
        ALLOCATED = 1
    } BlockStatus;

    struct MemoryBlock {
        uint64 start_addr;          // 起始地址  
        uint64 size;                // 分区大小
        BlockStatus status;         // 状态
        uint64 process_id;          // 所属进程的id
        struct MemoryBlock *prev;   // 前驱节点
        struct MemoryBlock *next;   // 后继节点
    };

    // 内存管理器
    struct MemoryManager {
        MemoryBlock *head;      // 链表头节点
        uint64_t total_size;    // 内存总大小
    };

    // 内存请求结构
    struct request {
        int process_id;     // 进程ID
        char op;           // 操作类型：'a'-分配, 'r'-释放  
        uint64_t size;     // 请求的内存大小（对于分配操作）
    };

    ```

*   **3.2 函数规格说明**

    *   **`load_requests(FILE*)`**
        - **功能**：从文件加载内存请求序列
        - **输入**：已打开的文件指针 （指向请求序列开始位置）
        - **处理**：解析每行请求，识别操作类型和参数
        - **输出**：返回请求列表 `[(1, 'a', 100), (1, 'r', 0), ...]`

    *   **`initialize_memory(total_size)`**
        - **功能**：初始化内存空间
        - **输入**：内存总大小
        - **处理**：创建初始空闲分区
        - **输出**：返回内存链表头节点

    *   **`first_fit(memory_list, size)`**
        - **功能**：首次适应算法
        - **输入**：内存链表，请求大小
        - **处理**：从链表头部查找第一个足够大的空闲分区
        - **输出**：返回分配结果（成功/失败）

    *   **`best_fit(memory_list, size)`**
        - **功能**：最佳适应算法
        - **输入**：内存链表，请求大小
        - **处理**：查找满足要求的最小空闲分区
        - **输出**：返回分配结果

    *   **`worst_fit(memory_list, size)`**
        - **功能**：最坏适应算法
        - **输入**：内存链表，请求大小
        - **处理**：查找最大的空闲分区进行分配
        - **输出**：返回分配结果

    *   **`release_memory(memory_list, process_id)`**
        - **功能**：释放指定进程分区
        - **输入**：内存链表，进程id
        - **处理**：标记分区为空闲，合并相邻空闲分区
        - **输出**：返回操作结果

    *   **`display_memory_status(memory_list)`**
        - **功能**：显示内存状态
        - **输入**：内存链表
        - **处理**：遍历链表，格式化输出分区信息
        - **输出**：打印空闲分区表和已分配分区表

*   **3.3 核心算法流程**

    *   **分配流程**：
        1. 遍历内存链表查找合适分区
        2. 找到后拆分分区（如剩余空间大于阈值）
        3. 更新分区状态
        4. 返回分配结果

    *   **释放流程**：
        1. 查找指定进程id所属的分区
        2. 标记状态为free
        3. 检查并合并前后相邻的空闲分区
        4. 更新链表结构

**【本部分目标】**：获得每个函数的详细实现规范，可直接开始编码。

---

#### **4. 编码实现计划**

1. 创建 `4-1.c` 文件
2. 按顺序实现：
   - 数据结构和基础类
   - 文件读取和初始化函数
   - 核心分配算法
   - 内存释放和合并功能
   - 状态显示功能
3. 创建主函数 `int main()` 整合所有模块


---

#### **5. 测试方案**

*   **测试用例**：
    - 验证三种算法的分配效果
    - 测试内存释放和合并功能
    - 检查分区表的正确性
*   **预期输出**：
    - 完整的内存状态变化过程
    - 最终的内存利用率统计
---

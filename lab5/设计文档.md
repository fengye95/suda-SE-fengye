# **一、简单文件系统模拟 - 项目概述**

## 📋 项目简介

**项目名称**：基于块分区的简单文件系统模拟  
**开发环境**：Linux + C语言  
**项目类型**：操作系统课程实验  
**核心创新**：采用"一个用户一块磁盘"的极简设计，清晰展示文件系统核心原理

## 🎯 设计目标

本项目通过极度简化的设计，实现一个易于理解但功能完整的文件系统模拟，重点展示：

- **资源分区管理**：每个用户独占固定的磁盘块空间

- **空间隔离机制**：用户间存储空间的完全隔离

- **分页存储管理**：在用户块内部实现页面级存储管理

- **二级目录结构**：主目录+用户目录的经典文件系统结构

- **无持久化存储**：程序退出后数据丢失，不模拟磁盘数据的持久化保存


## 功能范围边界（做什么）

- 用户管理：注册、登录、注销

- 文件操作：创建、删除、读取、写入、权限修改

- 目录操作：列表显示文件及属性

- 空间管理：查看磁盘使用情况

- 不包含：图形化界面、文本编辑器、文件共享、网络功能

您说得对！在项目概述部分的架构描述，应该保持高层次、结构性，而不需要深入到具体的数据流细节。数据流属于后面的详细设计部分。

我理解您的困惑了——现在的架构描述更多是**静态结构**，但缺少一点**动态逻辑**的暗示。让我在保持概述性质的前提下，让架构描述更有"架构感"。

---

## 🏗️ 系统架构（极简主义）

### 架构概览

本系统采用**分层隔离架构**，通过严格的资源划分实现多用户文件管理：

```
应用层 (用户命令)
    ↓
文件系统层 (命令解析、权限检查、资源管理)
    ↓  
存储层 (物理磁盘模拟 → 逻辑块划分 → 页面管理)
```

### 核心架构组件

#### 1. 存储架构
```
物理磁盘 (512KB)
    ↓
块分区 (8个64KB块)
    ↓
页面管理 (每个块内64个1KB页面)
```

- **块0**：系统块 - MFD主目录
- **块1-7**：用户块 - 每个用户独占一个块

#### 2. 数据架构
```
MFD (用户账户表) → UFD (用户文件列表) → FCB (文件元数据) → 数据页面
```

#### 3. 安全架构
- **垂直隔离**：用户→块 1:1 绑定
- **水平隔离**：用户间无法交叉访问
- **权限控制**：文件级读写保护码

### 架构特点

1. **清晰的关注点分离**
   - 用户管理 → MFD
   - 文件管理 → UFD  
   - 数据存储 → 页面分配

2. **可预测的资源分配**
   - 静态绑定：用户注册即确定磁盘块
   - 固定配额：每个用户64KB上限
   - 无竞争：资源预先分配，无运行时冲突

3. **简化的扩展路径**
   - 文件增长：通过页面链表动态扩展
   - 功能扩展：在现有层级上添加新模块

这样的架构描述既保持了概述的简洁性，又体现了系统各个部分如何协同工作的"架构思维"，同时为后面的详细设计（包括数据流）做好了铺垫。

您觉得这样的表述是否更好地体现了"架构感"？

## 🔧 功能特性

### 用户管理功能
- ✅ 用户注册（分配专属磁盘块）
- ✅ 用户登录验证
- ✅ 用户空间隔离

### 文件操作功能
- ✅ 文件创建与删除
- ✅ 文件读取与写入
- ✅ 文件属性管理
- ✅ 动态空间分配

### 系统管理功能
- ✅ 磁盘块分配管理
- ✅ 页面级存储管理
- ✅ 空间使用统计

## 🗂️ 技术规格

### 系统容量
- **总磁盘空间**：512KB
- **磁盘块大小**：64KB
- **页面大小**：1KB
- **最大用户数**：7个
- **单用户最大文件数**：受64KB空间限制

### 管理粒度
- **粗粒度**：用户级磁盘块分配
- **细粒度**：块内页面级文件管理
- **无外部碎片**：固定大小的块和页面

## 🎮 命令接口

```
系统级命令：
register - 注册新用户
login    - 用户登录
logout   - 用户登出
df       - 显示磁盘空间使用情况

文件级命令：
create   - 创建文件
delete   - 删除文件  
read     - 读取文件
write    - 写入文件
close    - 关闭文件
dir      - 列出文件
cat      - 查看文件内容
```

## 💡 教学价值

这个极度简化的设计虽然不适用于真实环境，但具有重要的教学意义：

1. **概念清晰**：每个核心概念都有直观的对应实现
2. **易于理解**：避免了真实文件系统的复杂性
3. **完整演示**：涵盖了文件系统所有关键组件
4. **代码简洁**：适合课程实验的代码规模

本项目完美平衡了功能完整性和实现简单性，是理解文件系统原理的理想教学工具。


# **二、简单文件系统模拟 - 数据结构设计**

您说得对，我们需要重新审视并修正数据流分析，确保它与我们最终确定的简化设计保持一致。

## 2.1 文件系统数据流分析（修正版）

### 2.1.1 核心数据流程
好的，我们先罗列核对一下核心数据流程：

#### 核心数据流程列表：

1. **系统初始化流程**
2. **用户注册流程** 
3. **用户登录流程**
4. **用户注销流程**
5. **文件创建流程**
6. **文件删除流程**
7. **文件读取流程**
8. **文件写入流程**
9. **目录列表流程**
10. **空间查询流程**

#### 需要确认的问题：

1. 是否缺少任何重要流程？
2. 是否有流程可以合并或拆分？
3. 流程的粒度是否合适？

请告诉我您觉得哪些流程需要调整，或者是否有遗漏的重要操作。

您说得对！我纠正一下磁盘块的编号：


#### **数据流1：系统初始化流程**
```
输入: 无

系统启动
    ↓
初始化MFD数组 → 建立7个用户槽位，预绑定磁盘块0-6
    ↓
初始化磁盘空间 → 创建512KB虚拟磁盘，划分7个64KB用户块 + 1个系统块
    ↓
分页初始化 → 将每个用户块划分为64个1KB页面
    ↓
初始化空闲页面管理器 → 为每个磁盘块建立空闲页面链表，包含所有64个页面
    ↓
初始化全局会话 → 设置未登录状态，清空当前用户上下文
    ↓
系统就绪 → 进入命令接收状态

输出: 系统初始化完成，等待用户命令
```

注：本流程在详细设计阶段进行了重要修正，增加了"初始化空闲页面管理器"步骤，以支持基于经典空闲链表算法的物理页面分配机制。

<br>

#### **数据流2：用户注册过程**
```
输入: 用户名, 密码

用户输入 [用户名, 密码]
    ↓
查找MFD空闲槽位 → 遍历数组找到首个 is_used = false 的槽位
    ↓
检查用户名冲突 → 确保用户名在MFD中唯一  
    ↓
填写用户信息 → 将用户名、密码写入该槽位，标记 is_used = true
    ↓
注册成功 → 该槽位立即生效，用户可登录使用

输出: 注册成功 / 失败（用户名冲突或无空闲槽位）
```

#### **数据流3：用户登录流程**
```
输入: 用户名, 密码

用户输入 [用户名, 密码]
    ↓
查找用户记录 → 在MFD数组中查找用户名且 is_used = true 的条目
    ↓
验证密码 → 比对输入的密码与存储的密码
    ↓
设置用户会话 → 记录当前用户信息，激活对应的UFD和磁盘块
    ↓
登录成功 → 进入该用户的文件操作环境

输出: 登录成功 / 失败（用户不存在或密码错误）
```


#### **数据流4：用户注销流程**
```
输入: 无（logout命令）

用户请求注销
    ↓
清理用户会话 → 清空当前用户上下文信息
    ↓
重置系统状态 → 恢复至未登录的初始状态
    ↓
注销成功 → 返回系统主界面，等待新用户登录

输出: 注销成功，返回登录界面
```

注：移除了"关闭打开文件 → 确保所有文件资源正确释放"步骤
原因已在数据流6中解释
<br>

#### **数据流5：文件创建流程**
```
输入: 文件名, 保护码
用户输入创建命令 [create 文件名 权限]
    ↓
验证用户权限 → 确认用户已登录，获取当前UFD
    ↓
检查文件名冲突 → 在当前用户UFD链表中检查文件名是否已存在
    ↓
分配初始页面 → 初始分配1个页面作为容量预留，但文件内容长度为0
    ↓
创建FCB条目 → 生成文件控制块，记录文件元数据（长度初始为0）
    ↓
更新UFD链表 → 将新FCB插入当前用户文件目录
    ↓
创建成功 → 返回文件创建完成信息
输出: 文件创建成功 / 失败（空间不足或文件名冲突）
```

#### **数据流6：文件删除流程**（修正版）
```
输入: 文件名
用户输入删除命令 [delete 文件名]
    ↓
查找目标文件 → 在当前用户UFD链表中查找指定文件FCB
    ↓
回收磁盘空间 → 释放文件占用的所有页面
    ↓
移除FCB条目 → 从UFD链表中删除该文件节点
    ↓
删除成功 → 返回文件删除完成信息
输出: 文件删除成功 / 失败（文件不存在）
```

注：移除了"检查文件状态 → 确认文件未被打开"步骤，因为我们不维护打开状态，我们只有read，write两种操作。 并不需要为此编写图形化文本编辑器（项目概述--功能边界 有提到）

这样的设计更加符合我们的简化目标！

<br>

#### **数据流7：文件读取流程**
```
输入: 文件名
用户输入读取命令 [read 文件名]
    ↓
查找文件FCB → 在当前用户UFD链表中查找指定文件
    ↓
验证读取权限 → 检查文件保护码是否包含读权限
    ↓
按页面链表读取 → 根据FCB中的页面链表顺序读取所有页面数据
    ↓
返回文件内容 → 将数据按正确顺序和长度返回给用户
输出: 文件内容 / 错误信息（文件不存在或无读权限）
```


#### **数据流8：文件写入流程**
```
输入: 文件名, 写入数据
用户输入写入命令 [write 文件名 数据]
    ↓
查找文件FCB → 在当前用户UFD链表中查找指定文件
    ↓
验证写入权限 → 检查文件保护码是否包含写权限
    ↓
分配所需页面 → 计算需要多少页面，分配或扩展页面
    ↓
写入数据 → 将数据按页面大小分割并写入对应页面
    ↓
更新文件元数据 → 更新FCB中的文件长度和修改时间
    ↓
返回写入结果 → 确认写入完成
输出: 写入成功 / 错误信息（文件不存在、无写权限或空间不足）
```

**关键点说明：**
- **动态扩展**：如果新数据比原文件大，会自动分配更多页面
- **页面管理**：数据按1KB大小分割到不同页面
- **元数据更新**：文件长度、修改时间等信息实时更新
- **空间检查**：写入前确保有足够的空闲页面


#### **数据流9：目录列表流程**（最终版）
```
输入: 无
用户输入列表命令 [dir]
    ↓
获取当前UFD → 从当前用户会话中获取UFD链表头
    ↓
遍历文件列表 → 顺序访问UFD链表中的每个FCB节点
    ↓
提取文件信息 → 从每个FCB中读取文件名、物理地址、保护码、文件长度、文件大小
    ↓
格式化输出 → 按表格形式组织并显示完整的文件信息
    ↓
返回目录内容 → 显示当前用户的所有文件详情
输出: 文件目录列表（包含文件名、物理地址、保护码、文件长度、文件大小）
```

**输出示例：**
```
文件名      物理地址    保护码   文件长度   文件大小
note.txt    0x1000      rw      1536      2048
report.doc  0x1400      r       3276      4096  
data.txt    0x2000      rw      820       1024
```

**关键说明：**
- **文件长度**：文件实际内容长度（1536 bytes）
- **文件大小**：文件占用的磁盘空间大小（2048 bytes）
- 由于分页管理，文件大小通常是页面大小的整数倍
- 可能存在内部碎片（如文件长度1536字节，但占用2048字节磁盘空间）

#### **数据流10：空间查询流程**
```
输入: 无
用户输入查询命令 [df]
    ↓
获取当前用户磁盘块 → 从会话中获取当前用户的磁盘块ID
    ↓
统计空间使用 → 遍历空闲链表计算已用和剩余空间
    ↓
收集统计信息 → 计算总空间、已用空间、剩余空间、使用比例
    ↓
格式化输出 → 以易读格式显示空间使用情况
    ↓
返回空间信息 → 显示当前用户的磁盘空间状态
输出: 空间使用统计（总大小、已用空间、剩余空间、使用率）
```

**输出示例：**
```
用户 user1 磁盘空间使用情况：
总空间:   64KB
已用空间: 24KB  
剩余空间: 40KB
使用率:   37.5%
```



---

## 2.2 详细数据结构设计

基于第2.1节的数据流分析，系统需维护以下五个核心数据结构以支持各项功能：

本系统定义的五类核心数据结构如下：

1.  **MFD（主文件目录）结构** - 系统级用户账户管理与磁盘块映射
2.  **UserSession（用户会话）结构** - 当前登录用户的操作上下文与权限状态
3.  **UFD（用户文件目录）结构** - 单用户文件集合管理
4.  **FCB（文件控制块）结构** - 单文件元数据与存储映射
5.  **FreePageManager（空闲页面管理）结构** - 磁盘块内物理页面的分配与回收

各结构的具体设计详见后续小节。

---

现在清晰多了。接下来我们就可以逐个展开每个结构的具体设计了。

好的，我们开始第一个数据结构的设计：

## 2.2.1 MFD（主文件目录）结构设计

### 设计目标
MFD是系统的核心管理结构，负责：
- 存储所有注册用户的账户信息
- 维护用户名到专属磁盘块的固定映射
- 提供用户登录验证的依据

### 数据结构定义
```c
#define MAX_USERNAME_LEN 10
#define MAX_PASSWORD_LEN 10
#define MAX_USERS 7

struct mfd_entry {
    char username[MAX_USERNAME_LEN];  // 用户名
    char password[MAX_PASSWORD_LEN];  // 密码
    int is_used;                      // 槽位使用标志：1=已使用，0=空闲
    int assigned_block_id;            // 分配的磁盘块ID（0-6）
    struct ufd_node* user_files;      // 指向用户文件目录链表
};

struct mfd_entry MFD_Table[MAX_USERS];  // 主文件目录表
```


### 关键设计说明
1. **固定大小数组**：系统最多支持7个用户，对应7个磁盘块
2. **直接映射**：`MFD_Table[i]` 固定绑定磁盘块 `i`
3. **预分配设计**：系统初始化时所有槽位的 `assigned_block_id` 就已确定
4. **懒初始化**：`user_files` 指针在用户首次注册时创建

### 支持的操作
- 用户注册：查找空闲槽位，填写用户信息
- 用户登录：验证用户名密码，建立用户会话
- 用户查询：遍历MFD表获取系统用户状态

这个设计是否符合您的预期？我们可以继续下一个数据结构，或者先深入讨论MFD的某个细节。


<br>
<br>


## 2.2.2 UserSession（用户会话）结构设计

### 设计目标
维护当前登录用户的操作上下文，实现用户操作的权限控制和资源隔离。

### 数据结构定义
```c
#define MAX_USERNAME_LEN 10

struct user_session {
    char current_user[MAX_USERNAME_LEN];  // 当前登录用户名
    int current_block_id;                 // 当前用户磁盘块ID
    struct ufd_node* current_ufd;         // 当前用户文件目录指针
    int is_logged_in;                     // 登录状态标志
};

struct user_session active_session;  // 全局唯一会话实例
```

### 关键设计说明
1. **全局单例**：系统在任何时刻只维护一个活跃会话
2. **上下文切换**：用户登录时填充，注销时清空
3. **权限基础**：所有文件操作依赖会话中的身份信息
4. **资源导向**：通过`current_ufd`和`current_block_id`直接定位用户资源

### 支持的操作
- 会话建立：用户登录时填充会话信息
- 权限验证：检查`is_logged_in`状态决定操作权限
- 资源访问：通过会话中的指针直接访问用户文件和数据
- 会话清理：用户注销时重置所有字段

### 数据流支撑
- **用户登录流程**：创建并填充会话信息
- **用户注销流程**：清空会话状态
- **所有文件操作**：依赖会话进行权限和资源验证

这个设计确保了系统的安全隔离——用户只能通过自己的会话来访问对应的资源。


<br>
<br>



## 2.2.3 UFD（用户文件目录）结构设计

### 设计目标
管理单个用户拥有的所有文件，提供文件的组织、查找和遍历能力。

### 数据结构定义
```c

// 双向链表节点
struct ufd_node {
    struct fcb* file_control_block;    // 指向文件控制块
    struct ufd_node* prev;             // 前驱指针
    struct ufd_node* next;             // 后继指针
};

// 用户文件目录头结构
struct user_file_directory {
    struct ufd_node* head;             // 文件链表头指针
    struct ufd_node* tail;             // 文件链表尾指针
    int file_count;                    // 文件总数统计
};
```

### 关键设计说明
1. **双向链表组织**：支持高效的双向遍历和简化的节点操作
2. **头尾指针**：便于在链表两端进行快速插入操作
3. **FCB分离**：UFD节点仅包含指针，FCB存储具体文件元数据
4. **计数优化**：维护`file_count`避免遍历统计
5. **用户隔离**：每个用户拥有独立的UFD实例

### 支持的操作
- **文件查找**：双向遍历链表按文件名查找FCB
- **文件添加**：在链表头部或尾部快速插入新文件节点
- **文件删除**：直接通过节点指针进行O(1)复杂度删除
- **目录列表**：双向遍历链表获取所有文件信息
- **空间统计**：通过`file_count`快速获取文件数量

### 与MFD的关系
```c
// MFD中的每个用户条目指向一个UFD
struct mfd_entry {
    char username[MAX_USERNAME_LEN];
    // ...
    struct user_file_directory* user_files;  // 明确的结构体指针
};
```

<br>

## 2.2.4 FCB（文件控制块）结构设计

### 设计目标
存储文件的完整元数据信息，包括文件属性、存储位置和访问权限。

### 数据结构定义
```c
#define MAX_FILENAME_LEN 10
#define FILE_ATTR_READ   0x01    // 0000 0001 - 读权限
#define FILE_ATTR_WRITE  0x02    // 0000 0010 - 写权限
// 未来可扩展其他权限位
#define FILE_ATTR_EXEC   0x04    // 0000 0100 - 执行权限（预留）
#define FILE_ATTR_HIDDEN 0x08    // 0000 1000 - 隐藏文件（预留）

struct fcb {
    char filename[MAX_FILENAME_LEN];   // 文件名
    int start_page;                    // 起始页面号
    int file_length;                   // 文件实际长度（字节）
    int file_size;                     // 文件占用空间大小（字节）
    unsigned int file_attributes;      // 文件属性，文件权限（位掩码）
    time_t create_time;                // 创建时间
    time_t modify_time;                // 修改时间
    int page_count;                    // 占用页面数量
    int next_page;                     // 下一个页面号（页面链表）
};
```

### 关键设计说明
1. **属性位掩码**：使用位运算管理文件属性和权限
2. **通用性设计**：`file_attributes`字段可扩展支持多种文件特性
3. **权限组合**：
   - 只读文件：`FILE_ATTR_READ`
   - 读写文件：`FILE_ATTR_READ | FILE_ATTR_WRITE`
4. **高效检查**：位运算提供快速的属性验证

### 支持的操作
- **权限验证**：通过属性位掩码检查读写权限
- **属性管理**：动态修改文件属性和权限设置
- **空间计算**：通过`page_count`计算文件占用空间
- **时间跟踪**：维护文件的创建和修改时间戳

这样的设计既清晰又具有很好的扩展性。



好的，您的精简版很好。删除那些繁琐的宏定义让文档更清晰，具体的位操作可以在实现代码中直接写，这样设计文档更专注于接口和结构。

---


您说得对！**核心操作语义**部分确实不属于数据结构设计文档，应该移到后续的**算法设计**或**接口设计**章节。

## 2.2.5 FreePageManager 结构

### 设计目标
基于经典空闲链表算法，管理每个磁盘块内64个1KB物理页面的分配与回收，提供类似Unix `kalloc/kfree` 的页面管理语义。

### 数据结构定义
```c
#define PAGES_PER_BLOCK 64
#define PAGE_SIZE 1024

// 空闲页面节点（直接存储在空闲页面内部）
struct free_page {
    struct free_page *next;  // 下一个空闲页面
};

// 磁盘块页面管理池
struct free_page_manager {
    struct free_page *freelist;  // 空闲页面链表头
    int free_count;              // 空闲页面数量
};

// 全局页面管理池（8个磁盘块）
struct free_page_manager page_pool[8];
```

### 关键设计说明
1. **零开销管理**：采用经典的空闲链表算法，将每个空闲物理页面的起始地址直接作为`struct free_page`链表节点使用。具体来说：
   - 每个64KB磁盘块中的64个1KB页面，在空闲时其开头8字节均存储一个`struct free_page`节点
   - 这些节点通过`next`指针串联，形成该磁盘块的空闲页面链表
   - 当页面被分配时，原本存储链表节点的8字节空间转为存储文件数据，页面身份从"管理节点"转换为"数据容器"
   - 此机制通过内存复用实现了管理结构的零额外内存开销
2. **经典算法**：采用xv6/Unix风格的空闲链表分配算法
3. **块内自治**：每个磁盘块独立管理自己的64个页面
4. **物理页面**：分配返回的是真实的物理页面起始地址
5. **初始化状态**：系统启动时所有页面都链接到对应freelist中

### 支持的操作
- **页面分配**：从freelist取出一个空闲页面
- **页面释放**：将页面归还到freelist
- **空间查询**：通过free_count获取空闲页面数量

### 与系统架构的关系
- 为FCB中的页面分配提供底层支持
- 与磁盘块绑定，确保用户空间隔离
- 在系统初始化时建立完整的空闲页面池

---

🎉 **数据结构设计阶段正式完成！**

<br><br>



# 🚀 下一阶段：**三、核心算法与接口设计**

## 3.0 设计原则与算法映射

### 算法设计原则
1. **极简主义优先**：所有算法采用最直接、最简单的实现方式
2. **教学清晰度**：代码可读性优于运行效率
3. **零优化策略**：不实现缓存、哈希、索引等优化机制
4. **线性操作**：广泛使用线性遍历、顺序查找等基础操作

### 数据流 → 算法映射

**数据流1**（系统初始化）→ **系统初始化算法** = MFD初始化 + 磁盘空间划分 + 空闲页面管理器初始化 + 全局会话初始化

**数据流2-3-4**（用户注册/登录/注销）→ **用户会话算法** = 用户查找 + 密码验证 + 会话管理

**数据流5**（文件创建）→ **文件创建算法** = 权限验证 + 文件名检查 + 页面分配 + FCB创建 + UFD插入

**数据流6**（文件删除）→ **文件删除算法** = 文件查找 + 页面释放 + UFD删除

**数据流7**（文件读取）→ **文件读取算法** = 权限验证 + 页面映射查找 + 数据组装

**数据流8**（文件写入）→ **文件写入算法** = 权限验证 + 空间分配 + 数据写入 + 元数据更新

**数据流9**（目录列表）→ **目录遍历算法** = UFD链表遍历 + 属性格式化

**数据流10**（空间查询）→ **空闲页面管理算法** = 空闲链表统计

---

现在8个核心算法完整对应所有数据流程，可以开始详细设计了。

### 算法范围界定
**包含的8个核心算法**：
0. 系统初始化算法
1. 用户会话算法
2. 文件创建算法  
3. 文件删除算法
4. 文件读取算法
5. 文件写入算法
6. 目录遍历算法
7. 空闲页面管理算法

**明确排除的复杂机制**：
- 多级页表映射
- 缓存替换算法
- 磁盘调度算法  
- 文件碎片整理
- 并发访问控制

### 复杂度接受标准
- 时间复杂度：接受O(n)线性复杂度
- 空间复杂度：接受O(1)或O(n)基础复杂度
- 不追求：O(log n)或O(1)高效复杂度

---

现在算法边界完全清晰，我们可以开始逐个设计这8个核心算法了。


---



您说得对！让我重新以**极简教学模型**的边界来列出剩余步骤：

## 📋 剩余设计步骤（极简版）

### **步骤三：核心算法设计**

### **步骤四：接口设计**
- 4.1 命令行参数解析
- 4.2 用户交互接口

### **步骤五：初始化详细设计**（必要）
- 5.1 系统启动序列 （main()函数设计）

---

## 🎯 极简边界确认

### **包含的**：
- 基础算法逻辑（伪代码级别）
- 主要函数接口
- 关键数据流转换

### **排除的**：
- 错误处理细节
- 性能优化逻辑
- 边界情况处理
- 完整的API文档

---

## 🏁 完成标准

**设计工作将在步骤五结束后正式完成**，届时：
1. 所有核心机制都已说明
2. 编码路径完全清晰
3. 教学演示价值充分体现